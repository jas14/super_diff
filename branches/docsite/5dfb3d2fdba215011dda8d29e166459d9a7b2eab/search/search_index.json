{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SuperDiff","text":"<p>This site hosts user- and contributor-facing documentation for SuperDiff, a Ruby gem that hooks into RSpec to intelligently display the differences between two data structures of any type.</p> <ul> <li>Learn how to use SuperDiff \u27a4</li> <li>Learn how to contribute to SuperDiff and dive into the source code \u27a4</li> <li>File a bug, submit a feature request, or suggest another change \u27a4</li> </ul>"},{"location":"contributors/","title":"Contributing to SuperDiff","text":"<p>Want to make a change to this project? Great! Here\u2019s how you do that.</p>"},{"location":"contributors/#1-install-dependencies","title":"1. Install dependencies","text":"<p>First, create a fork of the SuperDiff repo and clone it to your computer.</p> <p>Next, run the following command in the resulting directory in order to install dependencies. This will also install a Git hook which ensures all code is formatted whenever a commit is pushed:</p> <pre><code>bin/setup\n</code></pre>"},{"location":"contributors/#2-make-a-new-branch","title":"2. Make a new branch","text":"<p>It\u2019s best to follow GitHub Flow when working on this repo. Start by making a new branch to hold your changes:</p> <pre><code>git checkout -b &lt;name of your branch&gt;\n</code></pre>"},{"location":"contributors/#3-understand-the-codebase","title":"3. Understand the codebase","text":"<p>Some architectural documents have been provided to aid you in understanding the codebase. You might find the guide on how SuperDiff works to be helpful, for example.</p>"},{"location":"contributors/#4-write-and-run-tests","title":"4. Write and run tests","text":"<p>All code is backed by tests, so if you want to submit a pull request, make sure to update existing tests or write new ones if need be.</p> <p>There are two kinds of tests in this project:</p> <ul> <li>Unit tests, kept in <code>spec/unit</code>,   exercise individual classes and methods in isolation.</li> <li>Integration tests, kept in <code>spec/integration</code>,   exercise the interaction between SuperDiff, RSpec, and parts of Rails.</li> </ul> <p>It\u2019s best to run all of the tests after cloning SuperDiff to establish a baseline for any changes you want to make, but you can also run them at any time:</p> <pre><code>bundle exec rake\n</code></pre> <p>If you want to run one of the tests, say:</p> <pre><code>bin/rspec spec/integration/...\nbin/rspec spec/unit/...\n</code></pre> <p>Note that the integration tests can be quite slow to run. If you\u2019d like to speed them up, run the following command in a separate terminal session:</p> <pre><code>zeus start\n</code></pre> <p>Now the next time you run an integration test by saying</p> <pre><code>bin/rspec spec/integration/...\n</code></pre> <p>it should run twice as fast.</p>"},{"location":"contributors/#5-run-the-linter","title":"5. Run the linter","text":"<p>Code is linted and formatted using Prettier, so make sure that\u2019s set up in your editor. If you don\u2019t want to do this, you can also fix any lint violations by running:</p> <pre><code>yarn lint:fix\n</code></pre> <p>Provided that you ran <code>bin/setup</code> above, any code you\u2019ve changed will also be linted whenever you push a commit.</p>"},{"location":"contributors/#6-optional-update-the-documentation","title":"6. (Optional) Update the documentation","text":"<p>If there\u2019s any part of this documentation that you wish to update, then in a free terminal session, run:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>Now open <code>http://localhost:8000</code> to view a preview of the documentation locally.</p> <p>The files themselves are located in <code>docs/</code> and are written in Markdown. Updating any of these files will automatically be reflected in the preview.</p>"},{"location":"contributors/#7-submit-a-pull-request","title":"7. Submit a pull request","text":"<p>When you\u2019re done, push your branch and create a new pull request. I\u2019ll try to respond as quickly as I can. I may have suggestions about code style or your approach, but hopefully everything looks good and your changes get merged! Now you\u2019re a contributor! \ud83c\udf89</p>"},{"location":"contributors/how-rspec-works/","title":"How RSpec works","text":"<p>In order to understand how the RSpec integration in SuperDiff works, it\u2019s important to study the pieces in play within RSpec itself.</p>"},{"location":"contributors/how-rspec-works/#context","title":"Context","text":"<p>Imagine a file such as the following:</p> <pre><code># spec/some_spec.rb\ndescribe \"Some tests\" do\n  it \"does something\" do\n    expect([1, 2, 3]).to eq([1, 6, 3])\n  end\nend\n</code></pre> <p>Then, imagine that the user runs:</p> <pre><code>rspec\n</code></pre> <p>Without SuperDiff activated, this will produce the following output:</p> <pre><code>Some tests\n  does something (FAILED - 1)\n\nFailures:\n\n  1) Some tests does something\n     Failure/Error: expect([1, 2, 3]).to eq([1, 6, 3])\n\n       expected: [1, 6, 3]\n            got: [1, 2, 3]\n\n       (compared using ==)\n     # ./spec/some_spec.rb:3:in `block (2 levels) in &lt;top (required)&gt;'\n\nFinished in 0.01186 seconds (files took 0.07765 seconds to load)\n1 example, 1 failure\n\nFailed examples:\n\nrspec ./spec/some_spec.rb:2 # Some tests does something\n</code></pre> <p>Now imagine that we want to modify this output to replace the \u201cexpected:\u201d/\u201dactual:\u201d lines with a diff. How would we do this?</p>"},{"location":"contributors/how-rspec-works/#rspecs-cast-of-characters","title":"RSpec\u2019s cast of characters","text":"<p>First, we will review several concepts in RSpec: <sup>1</sup></p> <ul> <li>Since RSpec tests are \u201cjust Ruby\u201d,   parts of tests map to objects   which are created when those tests are loaded.   <code>describe</code>s and <code>context</code>s are represented by   example groups,   instances of <code>RSpec::Core::ExampleGroup</code>,   and <code>it</code>s and <code>specify</code>s are represented by   examples,   instances of <code>RSpec::Core::Example</code>.</li> <li>Most notably,   within tests themselves,   the <code>expect</code> method \u2014   mixed into tests via the syntax layer \u2014   returns an instance of <code>RSpec::Expectations::ExpectationTarget</code>,   and may raise an error if the check it is performing fails.</li> <li>Configuration is kept in an instance of <code>RSpec::Core::Configuration</code>,   which is accessible via <code>RSpec.configuration</code>   and is initialized the first time it\u2019s used</li> <li>The runner,   an instance of <code>RSpec::Core::Runner</code>,   is the entrypoint to all of RSpec \u2014   it\u2019s called directly by the <code>rspec</code> executable \u2014   and executes the tests the user has specified.</li> <li>Formatters change RSpec\u2019s output after running tests.   Since the user can specify one formatter when running <code>rspec</code>,   the collection of registered formatters is managed by the formatter loader,   an instance of <code>RSpec::Core::Formatters::Loader</code>.   The default formatter is \u201cprogress\u201d,   set in the configuration object,   which maps to an instance of <code>RSpec::Core::Formatters::ProgressFormatter</code>.</li> <li>Notifications   represent events that occur while running tests,   such as \u201cthese tests failed\u201d   or \u201cthis test was skipped\u201d.</li> <li>The reporter,   an instance of <code>RSpec::Core::Reporter</code>,   acts as sort of the brain of the whole operation.   Implementing a publish/subscribe model,   it tracks the state of tests as they are run,   including errors captured during the process,   packaging key moments into notifications   and delegating them to all registered formatters (or anything else listening to the reporter).   Like the configuration object,   it is also global,   accessible via the configuration object,   and is initialized the first time it\u2019s used</li> <li>The exception presenter,   an instance of <code>RSpec::Core::Formatters::ExceptionPresenter</code>,   is a special type of formatter   which does not respond to events,   but is rather responsible for managing all of the logic involved   in building all of the output that appears   when a test fails.</li> </ul>"},{"location":"contributors/how-rspec-works/#what-rspec-does","title":"What RSpec does","text":"<p>Given the above, RSpec performs the following sequence of events:</p> <ol> <li>The developer adds an failing assertion to a test using the following forms    (filling in <code>&lt;actual value&gt;</code>, <code>&lt;matcher&gt;</code>, <code>&lt;block&gt;</code>, and <code>&lt;args...&gt;</code> appropriately):</li> <li><code>expect(&lt;actual value&gt;).to &lt;matcher&gt;(&lt;args...&gt;)</code></li> <li><code>expect { &lt;block&gt; }.to &lt;matcher&gt;(&lt;args...&gt;)</code></li> <li><code>expect(&lt;actual value&gt;).not_to &lt;matcher&gt;(&lt;args...&gt;)</code></li> <li><code>expect { &lt;block&gt; }.not_to &lt;matcher&gt;(&lt;args...&gt;)</code></li> <li>The developer runs the test using the <code>rspec</code> executable.</li> <li>The <code>rspec</code> executable calls <code>RSpec::Core::Runner.invoke</code>.</li> <li>Skipping a few steps, <code>RSpec::Core::Runner#run_specs</code> is called,    which runs all tests by surrounding them in a call to <code>RSpec::Core::Reporter#report</code>.</li> <li>Skipping a few more steps, <code>RSpec::Core::Example#run</code> is called to run the current example.</li> <li>From here one of two paths is followed    depending on whether the assertion is positive (<code>.to</code>) or negative (<code>.not_to</code>).</li> <li>If it is positive:<ol> <li>Within the test,     after <code>expect</code> is called to build a <code>RSpec::Expectations::ExpectationTarget</code>,     the <code>to</code> method calls <code>RSpec::Expectations::PositiveExpectationHandler.handle_matcher</code>.</li> <li>The matcher is then used to know     whether the assertion passes or fails:     <code>PositiveExpectationHandler</code> calls the <code>matches?</code> method on the matcher.</li> <li>Assuming that <code>matches?</code> returns false,     <code>PositiveExpectationHandler</code> then calls <code>RSpec::Expectations::ExpectationHelper.handle_failure</code>,     telling it to get the positive failure message from the matcher     by calling <code>failure_message</code>.</li> </ol> </li> <li>If it is negative:<ol> <li>Within the test,     after <code>expect</code> is called to build a <code>RSpec::Expectations::ExpectationTarget</code>,     the <code>not_to</code> method calls <code>RSpec::Expectations::NegativeExpectationHandler.handle_matcher</code>.</li> <li>The matcher is then used to know     whether the assertion passes or fails:     <code>NegativeExpectationHandler</code>,     calls the <code>does_not_match?</code> method on the matcher.</li> <li>Assuming that <code>does_not_match?</code> returns false,     <code>NegativeExpectationHandler</code> then [calls <code>RSpec::Expectations::ExpectationHelper.handle_failure</code>][via <code>NegativeExpectationHandler</code>]rspec-expectation-helper-handle-failure-call-negative,     telling it to get the negative failure message from the matcher     by calling <code>failure_message_when_negated</code>.</li> </ol> </li> <li><code>RSpec::Expectations::ExpectationHelper.handle_failure</code> calls <code>RSpec::Expectations.fail_with</code>.</li> <li><code>RSpec::Expectations.fail_with</code> creates a diff using <code>RSpec::Matchers::MultiMatcherDiff</code>,    wraps it in an exception,    and feeds the exception to <code>RSpec::Support.notify_failure</code>.</li> <li><code>RSpec::Support.notify_failure</code> calls the currently set failure notifier,    which by default raises the given exception.</li> <li>Returning to <code>RSpec::Core::Example#run</code>,    this method rescues the exception    and then calls <code>finish</code>,    which calls <code>example_failed</code> on the reporter.</li> <li><code>RSpec::Core::Reporter#example_failed</code> uses <code>RSpec::Core::Notifications::ExampleNotification.for</code>    to construct a notification,    which in this case is an <code>RSpec::Core::Notifications::FailedExampleNotification</code>.    <code>RSpec::Core::Notifications::FailedExampleNotification</code> in turn    constructs an <code>RSpec::Core::Formatters::ExceptionPresenter</code>.</li> <li><code>RSpec::Core::Reporter#example_failed</code> then passes the notification object    along with an event of <code>:example_failed</code> to the <code>notify</code> method.    Because <code>RSpec::Core::Formatters::ProgressFormatter</code> is a listener on the reporter,    its <code>example_failed</code> method gets called,    which prints a message <code>Failure:</code> to the terminal.</li> <li>Returning to <code>RSpec::Core::Reporter#report</code>,    it now calls <code>finish</code> after all tests are run.</li> <li><code>RSpec::Core::Reporter#finish</code> notifies listeners of the <code>:dump_failures</code> event,    this time using an instance of <code>RSpec::Core::Notifications::ExamplesNotification</code>.    Again, because <code>RSpec::Core::Formatters::ProgressFormatter</code> is registered,    its <code>dump_failures</code> method is called,    which is actually defined in <code>RSpec::Core::Formatters::BaseTextFormatter</code>.</li> <li><code>RSpec::Core::Formatters::BaseTextFormatter#dump_failures</code> calls <code>RSpec::Core::Notifications::ExamplesNotification#fully_formatted_failed_examples</code>.</li> <li><code>RSpec::Core::Notifications::ExamplesNotification#fully_formatted_failed_examples</code> formats all of the failed examples    by wrapping them in <code>RSpec::Core::Notifications::FailedExampleNotification</code>s and calling <code>fully_formatted</code> on them.</li> <li><code>RSpec::Core::Notifications::FailedExampleNotification#fully_formatted</code> then calls <code>fully_formatted</code>    on its <code>RSpec::Core::Formatters::ExceptionPresenter</code>.</li> <li><code>RSpec::Core::Formatters::ExceptionPresenter#fully_formatted</code> then constructs various pieces    of what will eventually be printed to the terminal,    including the name of the test,    the line that failed,    the error and backtrace,    and other pertinent details.</li> </ol> <ol> <li> <p>Note that the analysis of the RSpec source code in this document is accurate as of RSpec v3.13.0, released February 4, 2024.\u00a0\u21a9</p> </li> </ol>"},{"location":"contributors/how-super-diff-works/","title":"How SuperDiff works","text":""},{"location":"contributors/how-super-diff-works/#superdiffs-cast-of-characters","title":"SuperDiff\u2019s cast of characters","text":"<ul> <li>An inspection tree builder (or, casually, an inspector)   makes use of an inspection tree   to generate a multi-line textual representation of an object,   similar to PrettyPrinter in Ruby or AwesomePrint,   but more appropriate for showing within a diff.</li> <li>An operation tree builder makes a comparison between two objects   (the \u201cexpected\u201d vs. the \u201cactual\u201d)   and generates an operation tree to represent the differences.</li> <li>An operation tree is made up of operations,   which designate differences in the inner parts of the two objects.   Those differences can be of type delete, insert, or change.   Since objects can be nested,   some operations can have children operations themselves,   hence the tree.</li> <li>An operation tree flattener takes an operation tree   and converts them to a set of lines,   which will aid in generating a diff.   Logic is applied to determine whether to place prefixes, suffixes, or commas.   Each operation may in fact generate more than one line   because the object that is specific to the operation is run through an inspector.</li> <li>A diff formatter takes a set of lines   and spits out a textual representation in the form of a conventional diff.</li> <li>A differ ties everything together   by figuring out which operation tree builder to use for a pair of expected and actual values,   building an operation tree,   and then converting it to a diff.</li> </ul>"},{"location":"contributors/how-super-diff-works/#where-superdiff-integrates-into-rspec","title":"Where SuperDiff integrates into RSpec","text":"<p>As described in \u201cHow RSpec works\u201d, when an assertion in a test fails \u2014 which happens when a matcher whose <code>matches?</code> method returns <code>false</code> is passed to <code>expect(...).to</code>, or when a matcher whose <code>does_not_match?</code> method returns <code>true</code> is passed to <code>expect(...).not_to</code> \u2014 RSpec will call the <code>RSpec::Expectations::ExpectationHelper#handle_failure</code> method, which will call <code>RSpec::Expectations.fail_with</code>. This method will use <code>RSpec::Matchers::ExpectedsForMultipleDiffs</code> and the differ object that <code>RSpec::Expectations.differ</code> returns to generate a diff, combining it with the failure message from the matcher, obtained by either calling <code>failure_message</code> or <code>failure_messsage_when_negated</code>, and then it will bundle them both into an error object. RSpec\u2019s runner will eventually capture this error and hand it to the reporter, which will display it via <code>RSpec::Core::Formatters::ExceptionPresenter</code>.</p> <p>Given this, there are a few things that SuperDiff needs to do in order to integrate fully with RSpec.</p> <ol> <li>First,    SuperDiff needs to get RSpec to use its differ instead of its own.    Unfortunately, while RSpec is very configurable,    it does not allow its differ to be substituted,    so the gem needs to do some amount of patching in order to achieve this.</li> <li>Second,    the gem needs to provide intelligent diffing    for all kinds of built-in matchers.    Many matchers in RSpec are marked as non-diffable \u2014    their <code>diffable?</code> method returns <code>false</code> \u2014    causing RSpec to not show a diff after the matcher\u2019s failure message    in the failure output.    The <code>contain_exactly</code> matcher is one such example.    SuperDiff turns this on \u2014    but the only way to do this is via patching.</li> <li>Lastly,    SuperDiff also modifies the failure messages for RSpec\u2019s built-in matchers    so that key words belonging to the \u201cexpected\u201d and \u201cactual\u201d values    get recolored.    Again, the only real way to do this is via patching.</li> </ol> <p>Here are all of the places that SuperDiff patches RSpec:</p> <ul> <li><code>RSpec::Expectations.differ</code>   (to use <code>SuperDiff::RSpec::Differ</code> instead of RSpec\u2019s own differ)</li> <li><code>RSpec::Expectations::ExpectationHelper#handle_failure</code>   (to consult the matcher for the \u201cexpected\u201d and \u201cactual\u201d values,   under special methods <code>expected_for_diff</code> and <code>actual_for_diff</code>)</li> <li><code>RSpec::Core::Formatters::ConsoleCodes</code>   (to allow for using SuperDiff\u2019s colors   and to remove the fallback in the absence of a specified color)</li> <li><code>RSpec::Core::Formatters::ExceptionPresenter</code>   (to recolor failure output)</li> <li><code>RSpec::Core::SyntaxHighlighter</code>   (to turn off syntax highlighting for code,   as it interferes with the previous patches)</li> <li><code>RSpec::Support::ObjectFormatter</code>   (to use SuperDiff\u2019s object inspectors)</li> <li><code>RSpec::Matchers::ExpectedsForMultipleDiffs</code>   (to add a key above the diff,   add spacing around the diff,   and colorize the word \u201cDiff:\u201d)</li> <li><code>RSpec::Matchers::Builtin::*</code>   (to reword failure messages across various matchers)</li> <li><code>RSpec::Matchers</code>   (to reset the <code>an_array_matching</code> alias for <code>match_array</code>,   and to ensure that <code>match_array</code> preserves behavior,   as it is backed by MatchArray class specific to SuperDiff)</li> </ul>"},{"location":"contributors/how-super-diff-works/#how-superdiffs-diff-engine-works","title":"How SuperDiff\u2019s diff engine works","text":"<p>With the internals of RSpec thoroughly explored, the internals of SuperDiff can finally be enumerated.</p> <p>Once a test fails and RSpec delegates to SuperDiff\u2019s differ, this sequence of events occurs:</p> <ol> <li><code>SuperDiff::Differs::Main.call</code> is called with a pair of values: <code>expected</code> and <code>actual</code>.    This method looks for a differ that is suitable for the pair    among a set of defaults and the list of differs registered via SuperDiff\u2019s configuration.    It does this by calling <code>.applies_to?</code> on each,    passing the <code>expected</code> and <code>actual</code>;    the first differ for whom this method returns <code>true</code> wins.    (This is a common pattern throughout the codebase.)    In most cases, if no differs are suitable,    then an error is raised,    although this is sometimes overridden.</li> <li>Once a differ is found,    its <code>.call</code> method is called.    Since all differs inherit from <code>SuperDiff::Differs::Base</code>,    <code>.call</code> always builds an operation tree,    but the type of operation tree to build    \u2014 or, more specifically, the operation tree builder subclass \u2014    is determined by the differ itself,    via the <code>operation_tree_builder_class</code> method.    For instance,    <code>SuperDiff::Differs::Array</code> uses a <code>SuperDiff::OperationTreeBuilder::Array</code>,    <code>SuperDiff::Differs::Hash</code> uses a <code>SuperDiff::OperationTreeBuilder::Hash</code>,    etc.</li> <li>Once the differ has an operation tree builder,    the differ calls <code>.call</code> on it    to build an operation tree.    Different operation tree builders do different things    depending on the types of objects,    but the end goal is to iterate over both the expected and actual values in tandem,    find the differences between them,    and represent those differences as operations.    An operation may be one of four types:    <code>insert</code>, <code>delete</code>, <code>change</code>, or <code>noop</code>.    In the case of collections \u2014    which covers most types of values \u2014    the diff is performed recursively.    This means that just as collections can have multiple levels,    so too can operation trees.</li> <li>Once the differ has an operation tree,    it then calls <code>to_diff</code> on it.    This method is defined in <code>SuperDiff::OperationTrees::Base</code>,    and it starts by first flattening the tree.</li> <li>This means that we need an operation tree flattener class.    Like differs,    operation trees specify which operation tree flattener they want to use    via the <code>operation_tree_flattener_class</code> method.</li> <li>Once the operation tree has a flattener class,    it calls <code>.call</code> on the class    to flatten the tree.</li> <li>Different types of flatteners also do different things,    but most of them operate on collection-based operation trees.    Since operation trees can have multiple level,    the flattening must be performed recursively.    The end result is a list of Line objects.</li> <li>Once the operation tree has been flattened,    then if the user has configured the gem to do so,    a step is performed to look for unchanged lines    (that is, operations of type <code>noop</code>)    and elide them \u2014    collapse them in such a way that the surrounding context is still visible.</li> <li>Once a set of elided lines is obtained,    the operation tree runs them through a formatter \u2014    so called <code>TieredLinesFormatter</code> \u2014    which will add the <code>-</code>s and <code>+</code>s along with splashes of color    to create the final format you see at the very end.</li> </ol> <p>In summary:</p> <pre><code>graph TB\n  DiffersMain[\"Differs::Main\"] -- Differs --&gt; Differ;\n  Differ -- Operation tree builder --&gt; OperationTree[Operation tree];\n  OperationTree -- Operation tree flattener --&gt; Lines;\n  Lines -- Tiered lines elider --&gt; ElidedLines[Elided lines];\n  ElidedLines -- Tiered lines formatter --&gt; FinalDiff[Final diff];</code></pre>"},{"location":"users/","title":"Introduction to SuperDiff","text":"<p>SuperDiff is a Ruby gem which is designed to display the differences between two objects of any type in a familiar and intelligent fashion.</p> <p>The primary motivation behind this gem is to vastly improve upon RSpec\u2019s built-in diffing capabilities. RSpec has many nice features, and one of them is that whenever you use a matcher such as <code>eq</code>, <code>match</code>, <code>include</code>, or <code>have_attributes</code>, you will get a diff of the two data structures you are trying to match against. This is great if all you want to do is compare multi-line strings. But if you want to compare other, more \u201creal world\u201d kinds of values such as API or database data, then you are out of luck. Since RSpec merely runs your <code>expected</code> and <code>actual</code> values through Ruby\u2019s PrettyPrinter library and then performs a diff of these strings, the output it produces leaves much to be desired.</p> <p>For instance, let\u2019s say you wanted to compare these two hashes:</p> <pre><code>actual = {\n  customer: {\n    person: SuperDiff::Test::Person.new(name: \"Marty McFly, Jr.\", age: 17),\n    shipping_address: {\n      line_1: \"456 Ponderosa Ct.\",\n      city: \"Hill Valley\",\n      state: \"CA\",\n      zip: \"90382\"\n    }\n  },\n  items: [\n    { name: \"Fender Stratocaster\", cost: 100_000, options: %w[red blue green] },\n    { name: \"Mattel Hoverboard\" }\n  ]\n}\n\nexpected = {\n  customer: {\n    person: SuperDiff::Test::Person.new(name: \"Marty McFly\", age: 17),\n    shipping_address: {\n      line_1: \"123 Main St.\",\n      city: \"Hill Valley\",\n      state: \"CA\",\n      zip: \"90382\"\n    }\n  },\n  items: [\n    { name: \"Fender Stratocaster\", cost: 100_000, options: %w[red blue green] },\n    { name: \"Chevy 4x4\" }\n  ]\n}\n</code></pre> <p>If, somewhere in a test, you were to say:</p> <pre><code>expect(actual).to eq(expected)\n</code></pre> <p>You would get output that looks like this:</p> <p></p> <p>What this library does is to provide a diff engine that knows how to figure out the differences between any two data structures and display them in a sensible way. So, using the example above, you\u2019d get this instead:</p> <p></p>"},{"location":"users/customization/","title":"Customizing SuperDiff","text":"<p>You can customize the behavior of the gem by opening your test helper file (<code>spec/rails_helper.rb</code> or <code>spec/spec_helper.rb</code>) and calling <code>SuperDiff.configure</code> with a configuration block:</p> <pre><code>SuperDiff.configure do |config|\n  # ...\nend\n</code></pre> <p>The following is a list of options you can set on the configuration object along with their defaults:</p> name description default <code>actual_color</code> The color used to display \u201cactual\u201d values in diffs <code>:yellow</code> <code>border_color</code> The color used to display the border in diff keys <code>:blue</code> <code>color_enabled</code> Whether to colorize output <code>true</code> if <code>ENV[\"CI\"]</code> or stdout is a TTY, <code>false</code> otherwise <code>diff_elision_enabled</code> Whether to elide (remove) unchanged lines in diff <code>false</code> <code>diff_elision_maximum</code> How large a section of consecutive unchanged lines can be before being elided <code>0</code> <code>elision_marker_color</code> The color used to display the marker substituted for elided lines in a diff <code>:cyan</code> <code>expected_color</code> The color used to display \u201cexpected\u201d values in diffs <code>:magenta</code> <code>header_color</code> The color used to display the \u201cDiff:\u201d header in failure messages <code>:white</code> <code>key_enabled</code> Whether to show the key above diffs <code>true</code> <p>The following is a list of methods you can call on the configuration object:</p> name description <code>add_extra_diff_formatter_classes</code> Additional classes with which to format diffs <code>add_extra_differ_classes</code> Additional classes with which to compute diffs for objects <code>add_extra_inspection_tree_builder_classes</code> Additional classes used to inspect objects <code>add_extra_operation_tree_builder_classes</code> Additional classes used to build operation trees for objects <code>add_extra_operation_tree_classes</code> Additional classes used to hold operations in diffs between objects <p>Read on for more information about available kinds of customizations.</p>"},{"location":"users/customization/#customizing-colors","title":"Customizing colors","text":"<p>If you don\u2019t like the colors that SuperDiff uses, you can change them like so:</p> <pre><code>SuperDiff.configure do |config|\n  config.actual_color = :green\n  config.expected_color = :red\n  config.border_color = :yellow\n  config.header_color = :yellow\nend\n</code></pre> <p>See <code>CSI::EightBitColor</code> in the codebase for the list of available colors you can use as values here.</p> <p>You can also completely disable colorized output:</p> <pre><code>SuperDiff.configure { |config| config.color_enabled = false }\n</code></pre>"},{"location":"users/customization/#disabling-the-key","title":"Disabling the key","text":"<p>By default, when a diff is displayed, a key appears above it. This key serves to clarify which colors and symbols belong to the \u201cexpected\u201d and \u201cactual\u201d values. However, you can disable the key as follows:</p> <pre><code>SuperDiff.configure { |config| config.key_enabled = false }\n</code></pre>"},{"location":"users/customization/#hiding-unchanged-lines","title":"Hiding unchanged lines","text":"<p>When looking at a large diff made up of many lines that do not change, it can be difficult to make out the lines that do. Text-oriented diffs, such as those you get from a conventional version control system, solve this problem by removing or \u201celiding\u201d those unchanged lines from the diff entirely. The same can be done in SuperDiff.</p> <p>For instance, the following configuration enables diff elision and ensures that within a block of unchanged lines, a maximum of only 3 lines are displayed:</p> <pre><code>SuperDiff.configure do |config|\n  config.diff_elision_enabled = true\n  config.diff_elision_maximum = 3\nend\n</code></pre> <p>A diff in which some lines are elided may look like this:</p> <pre><code>  [\n    # ...\n    \"American Samoa\",\n    \"Andorra\",\n-   \"Angola\",\n+   \"Anguilla\",\n    \"Antarctica\",\n    \"Antigua And Barbuda\",\n    # ...\n  ]\n</code></pre> <p>as opposed to:</p> <pre><code>  [\n    \"Afghanistan\",\n    \"Aland Islands\",\n    \"Albania\",\n    \"Algeria\",\n    \"American Samoa\",\n    \"Andorra\",\n-   \"Angola\",\n+   \"Anguilla\",\n    \"Antarctica\",\n    \"Antigua And Barbuda\",\n    \"Argentina\",\n    \"Armenia\",\n    \"Aruba\",\n    \"Australia\"\n  ]\n</code></pre>"},{"location":"users/customization/#diffing-custom-objects","title":"Diffing custom objects","text":"<p>If you are comparing two instances of a class which are specific to your project, the resulting diff may not look as good as diffs involving native or primitive objects. This happens because if SuperDiff doesn\u2019t recognize a class, it will fall back to a generic representation for the diff.</p> <p>There are two ways to solve this problem.</p>"},{"location":"users/customization/#adding-an-attributes_for_super_diff-method","title":"Adding an <code>attributes_for_super_diff</code> method","text":"<p>This is the easiest approach. If two objects have this method, SuperDiff will use the hash that this method returns to compare those objects and will compute a diff between them, which will show up in the output.</p>"},{"location":"users/customization/#example","title":"Example","text":"<p>For instance, say we have the following classes:</p> <pre><code>class Http\n  # ...\nend\n\nclass Order\n  def initialize(id, number)\n    @id = id\n    @number = number\n  end\nend\n\nclass OrderRequestor\n  def initialize(order)\n    @order = order\n    @http_library = Http.new\n  end\n\n  def request\n    @http_library.get(\"/orders/#{order.id}\")\n  end\nend\n\nclass OrderTracker\n  def initialize(order)\n    @order = order\n    @requestor = OrderRequestor.new(order)\n  end\nend\n</code></pre> <p>and we have two instances of these class as follows:</p> <pre><code>actual = OrderTracker.new(Order.new(id: 1, number: \"1000\"))\nexpected = OrderTracker.new(Order.new(id: 2, number: \"2000\"))\n</code></pre> <p>If we diff these two objects, then we will see something like:</p> <pre><code>  #&lt;OrderTracker:0x111111111 {\n-   @order=#&lt;Order:0x222222222 {\n-     id: 2,\n-     number: '2000'\n-   }&gt;,\n-   @requestor=#&lt;OrderRequestor:0x333333333 {\n-     @order=#&lt;Order:0x222222222 {\n-       id: 2,\n-       number: '2000'\n-     }&gt;,\n-     @http_library=#&lt;Http:0x444444444 {\n-     }&gt;\n-   }&gt;\n+   @order=#&lt;Order:0x555555555 {\n+     id: 1,\n+     number: '1000'\n+   }&gt;,\n+   @requestor=#&lt;OrderRequestor:0x666666666 {\n+     @order=#&lt;Order:0x555555555 {\n+       id: 1,\n+       number: '1000'\n+     }&gt;,\n+     @http_library=#&lt;Http:0x777777777 {\n+     }&gt;\n+   }&gt;\n  }&gt;\n</code></pre> <p>It is not difficult to see that this diff is fairly noisy. It would be good if we could exclude <code>requestor</code>, since it\u2019s a bit redundant, and it would help if we could collapse some of the lines as well. We also don\u2019t need to know the address of each object (the <code>0xXXXXXXXXX</code> bit).</p> <p>We can easily solve this by adding an <code>attributes_for_super_diff</code> method to OrderTracker, making sure to exclude <code>requestor</code>, and by adding a similar method to Order as well.</p> <pre><code>  class Order\n    def initialize(id, number)\n      @id = id\n      @number = number\n    end\n+\n+   def attributes_for_super_diff\n+     { id: @id, number: @number }\n+   end\n  end\n\n  class OrderTracker\n    def initialize(order)\n      @order = order\n      @requestor = OrderRequestor.new(order)\n    end\n+\n+   def attributes_for_super_diff\n+     { order: @order }\n+   end\n  end\n</code></pre> <p>If we performed another diff, we would now get:</p> <pre><code>  #&lt;OrderTracker {\n    order: #&lt;Order {\n-     id: 2,\n+     id: 1,\n-     number: '2000'\n+     number: '1000'\n-   }&gt;\n  }&gt;\n</code></pre>"},{"location":"users/customization/#registering-new-building-blocks","title":"Registering new building blocks","text":"<p>This approach is more advanced, but also offers the greatest flexibility.</p> <p>More information will be added here on how to do this, but in the meantime, the best example is the RSpec integration in SuperDiff itself.</p>"},{"location":"users/getting-started/","title":"Getting Started","text":"<p>SuperDiff is designed to be used different ways, depending on the type of project.</p>"},{"location":"users/getting-started/#integrated-with-rspec-in-a-rails-app","title":"Integrated with RSpec in a Rails app","text":"<p>If you\u2019re developing a Rails app, run the following command to add SuperDiff to your project:</p> <pre><code>bundle add super_diff --group test\n</code></pre> <p>Then add the following toward the top of <code>spec/rails_helper.rb</code>:</p> <pre><code>require \"super_diff/rspec-rails\"\n</code></pre> <p>At this point, you can write tests for parts of your app, and SuperDiff will be able to diff Rails-specific objects such as ActiveRecord models, ActionController response objects, instances of HashWithIndifferentAccess, etc., in addition to objects that ship with RSpec, such as matchers.</p> <p>You can now continue on to customizing SuperDiff.</p>"},{"location":"users/getting-started/#integrated-with-rspec-in-a-project-using-parts-of-rails","title":"Integrated with RSpec in a project using parts of Rails","text":"<p>If you\u2019re developing an app using Hanami or Sinatra, or merely using a part of Rails such as ActiveModel, run the following command to add SuperDiff to your project:</p> <pre><code>bundle add super_diff\n</code></pre> <p>After running <code>bundle install</code>, add the following toward the top of <code>spec/spec_helper.rb</code>:</p> <pre><code>require \"super_diff/rspec\"\n</code></pre> <p>Then, add one or all of the following lines:</p> <pre><code>require \"super_diff/active_support\"\nrequire \"super_diff/active_record\"\n</code></pre> <p>At this point, you can write tests for parts of your app, and SuperDiff will be able to diff objects depending on which path you required. For instance, if you required <code>super_diff/active_support</code>, then SuperDiff will be able to diff objects defined in ActiveSupport, such as HashWithIndifferentAccess, and if you required <code>super_diff/active_record</code>, it will be able to diff ActiveRecord models. In addition to these, it will also be able to diff objects that ship with RSpec, such as matchers.</p> <p>You can now continue on to customizing SuperDiff.</p>"},{"location":"users/getting-started/#integrated-with-rspec-in-a-ruby-project","title":"Integrated with RSpec in a Ruby project","text":"<p>If you\u2019re developing a library or other project that does not depend on any part of Rails, run the following command to add SuperDiff to your project:</p> <pre><code>bundle add super_diff\n</code></pre> <p>Now add the following toward the top of <code>spec/spec_helper.rb</code>:</p> <pre><code>require \"super_diff/rspec\"\n</code></pre> <p>At this point, you can write tests for parts of your app, and SuperDiff will be able to diff objects that ship with RSpec, such as matchers.</p> <p>You can now continue on to customizing SuperDiff.</p>"},{"location":"users/getting-started/#using-parts-of-superdiff-directly","title":"Using parts of SuperDiff directly","text":"<p>Although SuperDiff is primarily designed to integrate with RSpec, it can also be used on its own in other kinds of applications.</p> <p>First, install the gem:</p> <pre><code>bundle add super_diff\n</code></pre> <p>Then, require it somewhere:</p> <pre><code>require \"super_diff\"\n</code></pre> <p>From here, there are a couple of options you might find useful:</p> <ul> <li>If you want to compare two objects and display a friendly diff,   you can use the equality matcher interface:</li> </ul> <pre><code>SuperDiff::EqualityMatchers::Main.call(expected, actual)\n</code></pre> <ul> <li>Or, if you want to compare two objects and get a lower-level list of operations,   you can use the differ interface:</li> </ul> <pre><code>SuperDiff::Differs::Main.call(expected, actual)\n</code></pre>"}]}